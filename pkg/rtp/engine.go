package rtp

import (
	"github.com/pion/webrtc/v3"
)

type Engine struct {
	pcConfig webrtc.Configuration
}

func NewRtpEngine(config *RtpConfig) *Engine {

	//peerConnectionConfig := webrtc.Configuration{
	//	ICEServers: []webrtc.ICEServer{
	//		{
	//			URLs: []string{"stun:stun.l.google.com:19302"},
	//		},
	//	},
	//}
	//
	//m := &webrtc.MediaEngine{}
	//if err := m.RegisterDefaultCodecs(); err != nil {
	//	panic(err)
	//}
	//
	//// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	//// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	//// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	//// for each PeerConnection.
	//i := &interceptor.Registry{}
	//
	//// Use the default set of Interceptors
	//if err := webrtc.RegisterDefaultInterceptors(m, i); err != nil {
	//	panic(err)
	//}
	//
	//// Register a intervalpli factory
	//// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	//// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	//// A real world application should process incoming RTCP packets from viewers and forward them to senders
	//intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	//if err != nil {
	//	panic(err)
	//}
	//i.Add(intervalPliFactory)
	//
	//// Create a new RTCPeerConnection
	//peerConnection, err := webrtc.NewAPI(webrtc.WithMediaEngine(m), webrtc.WithInterceptorRegistry(i)).NewPeerConnection(peerConnectionConfig)
	//if err != nil {
	//	panic(err)
	//}
	return &Engine{}
}

func (e Engine) NewPeerConnection(sdp *webrtc.SessionDescription) (*webrtc.PeerConnection, error) {
	//peerConnection, err := api.NewPeerConnection(webrtc.Configuration{})
	//if err != nil {
	//	return "", err
	//}
	//
	//streamMapLock.Lock()
	//defer streamMapLock.Unlock()
	//stream, err := getStream(streamKey)
	//if err != nil {
	//	return "", err
	//}
	//
	//peerConnection.OnTrack(func(remoteTrack *webrtc.TrackRemote, rtpReceiver *webrtc.RTPReceiver) {
	//	if strings.HasPrefix(remoteTrack.Codec().RTPCodecCapability.MimeType, "audio") {
	//		audioWriter(remoteTrack, stream.audioTrack)
	//	} else {
	//		videoWriter(remoteTrack, stream, peerConnection, stream)
	//
	//	}
	//})
	//
	//peerConnection.OnICEConnectionStateChange(func(i webrtc.ICEConnectionState) {
	//	if i == webrtc.ICEConnectionStateFailed {
	//		if err := peerConnection.Close(); err != nil {
	//			log.Println(err)
	//		}
	//		deleteStream(streamKey)
	//	}
	//})
	//
	//if err := peerConnection.SetRemoteDescription(webrtc.SessionDescription{
	//	SDP:  string(offer),
	//	Type: webrtc.SDPTypeOffer,
	//}); err != nil {
	//	return "", err
	//}
	//
	//gatherComplete := webrtc.GatheringCompletePromise(peerConnection)
	//answer, err := peerConnection.CreateAnswer(nil)
	//
	//if err != nil {
	//	return "", err
	//} else if err = peerConnection.SetLocalDescription(answer); err != nil {
	//	return "", err
	//}
	//
	//<-gatherComplete
	//return peerConnection.LocalDescription().SDP, nil
	return nil, nil
}
